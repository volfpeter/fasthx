{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Source code: https://github.com/volfpeter/fasthx</p> <p>Documentation and examples: https://volfpeter.github.io/fasthx</p>"},{"location":"#fasthx","title":"FastHX","text":"<p>FastAPI server-side rendering with built-in HTMX support.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Decorator syntax that works with FastAPI as one would expect, no need for unused or magic dependencies in routes.</li> <li>Built for HTMX, but can be used without it.</li> <li>Works with any templating engine or server-side rendering library, e.g. <code>htmy</code>, <code>jinja2</code>, or <code>dominate</code>.</li> <li>Gives the rendering engine access to all dependencies of the decorated route.</li> <li>HTMX routes work as expected if they receive non-HTMX requests, so the same route can serve data and render HTML at the same time.</li> <li>Response headers you set in your routes are kept after rendering, as you would expect in FastAPI.</li> <li>Correct typing makes it possible to apply other (typed) decorators to your routes.</li> <li>Works with both sync and async routes.</li> </ul>"},{"location":"#support","title":"Support","text":"<p>Consider supporting the development and maintenance of the project through sponsoring, or reach out for consulting so you can get the most out of the library.</p>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI and can be installed with:</p> <pre><code>$ pip install fasthx\n</code></pre> <p>The package has optional dependencies for the following official integrations:</p> <ul> <li>htmy: <code>pip install fasthx[htmy]</code>.</li> <li>jinja: <code>pip install fasthx[jinja]</code>.</li> </ul>"},{"location":"#core-concepts","title":"Core concepts","text":"<p>The core concept of FastHX is to let FastAPI routes do their usual job of handling the business logic and returning the result, while the FastHX decorators take care of the entire rendering / presentation layer using a declarative, decorator-based approach.</p> <p>Interally, FastHX decorators always have access to the decorated route's result, all of its arguments (sometimes called the request context), and the current request. Integrations convert these values into data that can be consumed by the used rendering engine (for example <code>htmy</code> or <code>jinja</code>), run the rendering engine with the selected component (more on this below) and the created data, and return the result to the client. For more details on how data conversion works and how it can be customized, please see the API documentation of the rendering engine integration of your choice.</p> <p>The <code>ComponentSelector</code> abstraction makes it possible to declaratively specify and dynamically select the component that should be used to render the response to a given request. It is also possible to define an \"error\" <code>ComponentSelector</code> that is used if the decorated route raises an exception -- a typical use-case being error rendering for incorrect user input.</p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>The only dependency of this package is <code>fastapi</code>.</p>"},{"location":"#development","title":"Development","text":"<p>Use <code>ruff</code> for linting and formatting, <code>mypy</code> for static code analysis, and <code>pytest</code> for testing.</p> <p>The documentation is built with <code>mkdocs-material</code> and <code>mkdocstrings</code>.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community to help improve the project! Whether you're an experienced developer or just starting out, there are many ways you can contribute:</p> <ul> <li>Discuss: Join our Discussion Board to ask questions, share ideas, provide feedback, and engage with the community.</li> <li>Document: Help improve the documentation by fixing typos, adding examples, and updating guides to make it easier for others to use the project.</li> <li>Develop: Prototype requested features or pick up issues from the issue tracker.</li> <li>Share: Share your own project by adding it to the external examples list, helping others discover and benefit from your work.</li> <li>Test: Write tests to improve coverage and enhance reliability.</li> </ul>"},{"location":"#license-mit","title":"License - MIT","text":"<p>The package is open-sourced under the conditions of the MIT license.</p>"},{"location":"api/component_selectors/","title":"Component Selectors","text":""},{"location":"api/component_selectors/#fasthx.component_selectors","title":"<code>fasthx.component_selectors</code>","text":""},{"location":"api/component_selectors/#fasthx.component_selectors.ComponentHeader","title":"<code>ComponentHeader</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Component selector that takes the component key from a request header.</p> <p>This class makes it possible for the client to submit the key/ID of the required component to the server in a header. This component selector will look up the requested component factory and return it for rendering.</p> <p>If the client doesn't request a specific component, then <code>default</code> will be used if it was set, otherwise an exception will be raised.</p> <p>By default this class treats component keys as case-insensitive. If you'd like to disable this behavior, set <code>case_sensitive</code> to <code>True</code>.</p> <p>This component selector also support error rendering.</p> Implements <ul> <li><code>RequestComponentSelector</code>.</li> </ul> Source code in <code>fasthx/component_selectors.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass ComponentHeader(Generic[T]):\n    \"\"\"\n    Component selector that takes the component key from a request header.\n\n    This class makes it possible for the client to submit the *key/ID* of the required component\n    to the server in a header. This component selector will look up the requested component\n    factory and return it for rendering.\n\n    If the client doesn't request a specific component, then `default` will be used if it was set,\n    otherwise an exception will be raised.\n\n    By default this class treats component keys as case-insensitive. If you'd like to disable\n    this behavior, set `case_sensitive` to `True`.\n\n    This component selector also support error rendering.\n\n    Implements:\n        - `RequestComponentSelector`.\n    \"\"\"\n\n    header: str\n    \"\"\"The header which is used by the client to communicate the *key* of the requested component.\"\"\"\n\n    components: dict[str, T]\n    \"\"\"Dictionary that maps errors to component factories.\"\"\"\n\n    error: type[Exception] | tuple[type[Exception], ...] | None = field(default=None, kw_only=True)\n    \"\"\"The accepted error or errors.\"\"\"\n\n    default: T | None = field(default=None, kw_only=True)\n    \"\"\"The component factory to use if the client didn't request a specific one.\"\"\"\n\n    case_sensitive: bool = field(default=False, kw_only=True)\n    \"\"\"Whether the keys of `components` are case-sensitive or not (default is `False`).\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        if not self.case_sensitive:\n            object.__setattr__(\n                self,\n                \"components\",\n                {k.lower(): v for k, v in self.components.items()},\n            )\n\n    def get_component(self, request: Request, error: Exception | None) -&gt; T:\n        \"\"\"\n        Returns the component factory to use to render the response.\n\n        If the request doesn't contain a header (with the name `self.header`),\n        then `self.default` will be returned if it's not `None`.\n\n        Raises:\n            KeyError: If the client request an unknown component or if no component\n                was requested and there is no default either.\n        \"\"\"\n        if error is not None and (self.error is None or not isinstance(error, self.error)):\n            raise error\n\n        if (key := request.headers.get(self.header, None)) is not None:\n            if not self.case_sensitive:\n                key = key.lower()\n\n            return self.components[key]\n        elif self.default is None:\n            raise KeyError(\"Default component factory was not set and header was not found.\")\n        else:\n            return self.default\n</code></pre>"},{"location":"api/component_selectors/#fasthx.component_selectors.ComponentHeader.case_sensitive","title":"<code>case_sensitive = field(default=False, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the keys of <code>components</code> are case-sensitive or not (default is <code>False</code>).</p>"},{"location":"api/component_selectors/#fasthx.component_selectors.ComponentHeader.components","title":"<code>components</code>  <code>instance-attribute</code>","text":"<p>Dictionary that maps errors to component factories.</p>"},{"location":"api/component_selectors/#fasthx.component_selectors.ComponentHeader.default","title":"<code>default = field(default=None, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The component factory to use if the client didn't request a specific one.</p>"},{"location":"api/component_selectors/#fasthx.component_selectors.ComponentHeader.error","title":"<code>error = field(default=None, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The accepted error or errors.</p>"},{"location":"api/component_selectors/#fasthx.component_selectors.ComponentHeader.header","title":"<code>header</code>  <code>instance-attribute</code>","text":"<p>The header which is used by the client to communicate the key of the requested component.</p>"},{"location":"api/component_selectors/#fasthx.component_selectors.ComponentHeader.get_component","title":"<code>get_component(request, error)</code>","text":"<p>Returns the component factory to use to render the response.</p> <p>If the request doesn't contain a header (with the name <code>self.header</code>), then <code>self.default</code> will be returned if it's not <code>None</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the client request an unknown component or if no component was requested and there is no default either.</p> Source code in <code>fasthx/component_selectors.py</code> <pre><code>def get_component(self, request: Request, error: Exception | None) -&gt; T:\n    \"\"\"\n    Returns the component factory to use to render the response.\n\n    If the request doesn't contain a header (with the name `self.header`),\n    then `self.default` will be returned if it's not `None`.\n\n    Raises:\n        KeyError: If the client request an unknown component or if no component\n            was requested and there is no default either.\n    \"\"\"\n    if error is not None and (self.error is None or not isinstance(error, self.error)):\n        raise error\n\n    if (key := request.headers.get(self.header, None)) is not None:\n        if not self.case_sensitive:\n            key = key.lower()\n\n        return self.components[key]\n    elif self.default is None:\n        raise KeyError(\"Default component factory was not set and header was not found.\")\n    else:\n        return self.default\n</code></pre>"},{"location":"api/core-decorators/","title":"Core Decorators","text":""},{"location":"api/core-decorators/#fasthx.hx","title":"<code>fasthx.hx(render, *, no_data=False, render_error=None)</code>","text":"<p>Decorator that converts a FastAPI route's return value into HTML if the request was an HTMX one.</p> <p>Parameters:</p> Name Type Description Default <code>render</code> <code>HTMLRenderer[T]</code> <p>The render function converting the route's return value to HTML.</p> required <code>no_data</code> <code>bool</code> <p>If set, the route will only accept HTMX requests.</p> <code>False</code> <code>render_error</code> <code>HTMLRenderer[Exception] | None</code> <p>Optional render function for handling exceptions raised by the decorated route. If not <code>None</code>, it is expected to raise an error if the exception can not be rendered.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[MaybeAsyncFunc[P, T]], Callable[P, Coroutine[None, None, T | Response]]]</code> <p>The rendered HTML for HTMX requests, otherwise the route's unchanged return value.</p> Source code in <code>fasthx/core_decorators.py</code> <pre><code>def hx(\n    render: HTMLRenderer[T],\n    *,\n    no_data: bool = False,\n    render_error: HTMLRenderer[Exception] | None = None,\n) -&gt; Callable[[MaybeAsyncFunc[P, T]], Callable[P, Coroutine[None, None, T | Response]]]:\n    \"\"\"\n    Decorator that converts a FastAPI route's return value into HTML if the request was\n    an HTMX one.\n\n    Arguments:\n        render: The render function converting the route's return value to HTML.\n        no_data: If set, the route will only accept HTMX requests.\n        render_error: Optional render function for handling exceptions raised by the decorated route.\n            If not `None`, it is expected to raise an error if the exception can not be rendered.\n\n    Returns:\n        The rendered HTML for HTMX requests, otherwise the route's unchanged return value.\n    \"\"\"\n\n    def decorator(func: MaybeAsyncFunc[P, T]) -&gt; Callable[P, Coroutine[None, None, T | Response]]:\n        @wraps(func)\n        async def wrapper(\n            __hx_request: DependsHXRequest, *args: P.args, **kwargs: P.kwargs\n        ) -&gt; T | Response:\n            if no_data and __hx_request is None:\n                raise HTTPException(\n                    status.HTTP_400_BAD_REQUEST, \"This route can only process HTMX requests.\"\n                )\n\n            try:\n                result = await execute_maybe_sync_func(func, *args, **kwargs)\n                renderer = render\n            except Exception as e:\n                # Reraise if not HX request, because the checks later don't differentiate between\n                # error and non-error result objects.\n                if render_error is None or __hx_request is None:\n                    raise e\n\n                result = e  # type: ignore[assignment]\n                renderer = render_error  # type: ignore[assignment]\n\n            if __hx_request is None or isinstance(result, Response):\n                return result\n\n            response = get_response(kwargs)\n            rendered = await execute_maybe_sync_func(renderer, result, context=kwargs, request=__hx_request)\n\n            return (\n                HTMLResponse(\n                    rendered,\n                    # The default status code of the FastAPI Response dependency is None\n                    # (not allowed by the typing but required for FastAPI).\n                    status_code=getattr(response, \"status_code\", 200) or 200,\n                    headers=getattr(response, \"headers\", None),\n                    background=getattr(response, \"background\", None),\n                )\n                if isinstance(rendered, str)\n                else rendered\n            )\n\n        return append_to_signature(\n            wrapper,  # type: ignore[arg-type]\n            inspect.Parameter(\n                \"__hx_request\",\n                inspect.Parameter.KEYWORD_ONLY,\n                annotation=DependsHXRequest,\n            ),\n        )\n\n    return decorator\n</code></pre>"},{"location":"api/core-decorators/#fasthx.page","title":"<code>fasthx.page(render, *, render_error=None)</code>","text":"<p>Decorator that converts a FastAPI route's return value into HTML.</p> <p>Parameters:</p> Name Type Description Default <code>render</code> <code>HTMLRenderer[T]</code> <p>The render function converting the route's return value to HTML.</p> required <code>render_error</code> <code>HTMLRenderer[Exception] | None</code> <p>Optional render function for handling exceptions raised by the decorated route. If not <code>None</code>, it is expected to raise an error if the exception can not be rendered.</p> <code>None</code> Source code in <code>fasthx/core_decorators.py</code> <pre><code>def page(\n    render: HTMLRenderer[T],\n    *,\n    render_error: HTMLRenderer[Exception] | None = None,\n) -&gt; Callable[[MaybeAsyncFunc[P, T]], Callable[P, Coroutine[None, None, Response]]]:\n    \"\"\"\n    Decorator that converts a FastAPI route's return value into HTML.\n\n    Arguments:\n        render: The render function converting the route's return value to HTML.\n        render_error: Optional render function for handling exceptions raised by the decorated route.\n            If not `None`, it is expected to raise an error if the exception can not be rendered.\n    \"\"\"\n\n    def decorator(func: MaybeAsyncFunc[P, T]) -&gt; Callable[P, Coroutine[None, None, Response]]:\n        @wraps(func)\n        async def wrapper(\n            __page_request: DependsPageRequest, *args: P.args, **kwargs: P.kwargs\n        ) -&gt; T | Response:\n            try:\n                result = await execute_maybe_sync_func(func, *args, **kwargs)\n                renderer = render\n            except Exception as e:\n                if render_error is None:\n                    raise e\n\n                result = e  # type: ignore[assignment]\n                renderer = render_error  # type: ignore[assignment]\n\n            if isinstance(result, Response):\n                return result\n\n            response = get_response(kwargs)\n            rendered = await execute_maybe_sync_func(\n                renderer, result, context=kwargs, request=__page_request\n            )\n            return (\n                HTMLResponse(\n                    rendered,\n                    # The default status code of the FastAPI Response dependency is None\n                    # (not allowed by the typing but required for FastAPI).\n                    status_code=getattr(response, \"status_code\", 200) or 200,\n                    headers=getattr(response, \"headers\", None),\n                    background=getattr(response, \"background\", None),\n                )\n                if isinstance(rendered, str)\n                else rendered\n            )\n\n        return append_to_signature(\n            wrapper,  # type: ignore[arg-type]\n            inspect.Parameter(\n                \"__page_request\",\n                inspect.Parameter.KEYWORD_ONLY,\n                annotation=DependsPageRequest,\n            ),\n        )\n\n    return decorator\n</code></pre>"},{"location":"api/dependencies/","title":"FastAPI Dependencies","text":""},{"location":"api/dependencies/#fasthx.DependsHXRequest","title":"<code>fasthx.DependsHXRequest = Annotated[Request | None, Depends(get_hx_request)]</code>  <code>module-attribute</code>","text":"<p>Annotated type (dependency) for <code>get_hx_request()</code> for FastAPI.</p>"},{"location":"api/dependencies/#fasthx.get_hx_request","title":"<code>fasthx.get_hx_request(request, hx_request=None)</code>","text":"<p>FastAPI dependency that returns the current request if it is an HTMX one, i.e. it contains an <code>\"HX-Request: true\"</code> header.</p> Source code in <code>fasthx/dependencies.py</code> <pre><code>def get_hx_request(\n    request: FARequest, hx_request: Annotated[str | None, Header()] = None\n) -&gt; Request | None:\n    \"\"\"\n    FastAPI dependency that returns the current request if it is an HTMX one,\n    i.e. it contains an `\"HX-Request: true\"` header.\n    \"\"\"\n    return request if hx_request == \"true\" else None\n</code></pre>"},{"location":"api/htmy/","title":"HTMY","text":""},{"location":"api/htmy/#fasthx.htmy","title":"<code>fasthx.htmy</code>","text":""},{"location":"api/htmy/#fasthx.htmy.ComponentHeader","title":"<code>ComponentHeader</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ComponentHeader[HTMYComponentFactory[T]]</code></p> <p><code>RequestComponentSelector</code> for HTMY components that takes selects the rendered component based on a request header.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>class ComponentHeader(_ComponentHeader[HTMYComponentFactory[T]]):\n    \"\"\"\n    `RequestComponentSelector` for HTMY components that takes selects the rendered component\n    based on a request header.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.CurrentRequest","title":"<code>CurrentRequest</code>","text":"<p>HTMY context aware utility for accessing the current request.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>class CurrentRequest:\n    \"\"\"\n    HTMY context aware utility for accessing the current request.\n    \"\"\"\n\n    @classmethod\n    def to_context(cls, request: Request) -&gt; h.MutableContext:\n        \"\"\"Creates an `htmy` `Context` for the given request.\"\"\"\n        return {Request: request}\n\n    @classmethod\n    def from_context(cls, context: h.Context) -&gt; Request:\n        \"\"\"\n        Loads the current `Request` instance from the given context.\n\n        Raises:\n            KeyError: If the there's no `Request` in the context.\n            TypeError: If invalid data is stored for `Request`.\n        \"\"\"\n        result = context[Request]\n        if isinstance(result, Request):\n            return result\n\n        raise TypeError(f\"Invalid context data for {cls.__name__}.\")\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.CurrentRequest.from_context","title":"<code>from_context(context)</code>  <code>classmethod</code>","text":"<p>Loads the current <code>Request</code> instance from the given context.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the there's no <code>Request</code> in the context.</p> <code>TypeError</code> <p>If invalid data is stored for <code>Request</code>.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>@classmethod\ndef from_context(cls, context: h.Context) -&gt; Request:\n    \"\"\"\n    Loads the current `Request` instance from the given context.\n\n    Raises:\n        KeyError: If the there's no `Request` in the context.\n        TypeError: If invalid data is stored for `Request`.\n    \"\"\"\n    result = context[Request]\n    if isinstance(result, Request):\n        return result\n\n    raise TypeError(f\"Invalid context data for {cls.__name__}.\")\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.CurrentRequest.to_context","title":"<code>to_context(request)</code>  <code>classmethod</code>","text":"<p>Creates an <code>htmy</code> <code>Context</code> for the given request.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>@classmethod\ndef to_context(cls, request: Request) -&gt; h.MutableContext:\n    \"\"\"Creates an `htmy` `Context` for the given request.\"\"\"\n    return {Request: request}\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.HTMY","title":"<code>HTMY</code>  <code>dataclass</code>","text":"<p>HTMY renderer utility with FastAPI route decorators.</p> <p>The following data is added automatically to every <code>HTMY</code> rendering context:</p> <ul> <li>The current <code>Request</code> that can be retrieved with <code>CurrentRequest.from_context()</code> in components.</li> <li>All route parameters (as a <code>RouteParams</code> instance) that can be retrieved with   <code>RouteParams.from_context()</code> in components.</li> <li>Everything added through <code>self.request_processors</code>.</li> <li>The default context of <code>self.htmy</code>.</li> </ul> Source code in <code>fasthx/htmy.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass HTMY:\n    \"\"\"\n    HTMY renderer utility with FastAPI route decorators.\n\n    The following data is added automatically to every `HTMY` rendering context:\n\n    - The current `Request` that can be retrieved with `CurrentRequest.from_context()` in components.\n    - All route parameters (as a `RouteParams` instance) that can be retrieved with\n      `RouteParams.from_context()` in components.\n    - Everything added through `self.request_processors`.\n    - The default context of `self.htmy`.\n    \"\"\"\n\n    htmy: h.Renderer = field(default_factory=h.Renderer)\n    \"\"\"The HTMY renderer to use.\"\"\"\n\n    no_data: bool = field(default=False, kw_only=True)\n    \"\"\"\n    If set, `hx()` routes will only accept HTMX requests.\n\n    Note that if this property is `True`, then the `hx()` decorator's `no_data` argument\n    will have no effect.\n    \"\"\"\n\n    request_processors: list[RequestProcessor] = field(default_factory=list, kw_only=True)\n    \"\"\"\n    A list of functions that expect the current request and return an `htmy` `Context` that should\n    be used during rendering in addition to the default context of `self.htmy`.\n    \"\"\"\n\n    def hx(\n        self,\n        component_selector: HTMYComponentSelector[T],\n        *,\n        error_component_selector: HTMYComponentSelector[Exception] | None = None,\n        no_data: bool = False,\n    ) -&gt; Callable[[MaybeAsyncFunc[P, T]], Callable[P, Coroutine[None, None, T | Response]]]:\n        \"\"\"\n        Decorator for rendering the route's result if the request was an HTMX one.\n\n        Arguments:\n            component_selector: The component selector to use.\n            error_component_selector: The component selector to use for route error rendering.\n            no_data: If set, the route will only accept HTMX requests.\n        \"\"\"\n        return hx(\n            self._make_render_function(component_selector),\n            render_error=None\n            if error_component_selector is None\n            else self._make_error_render_function(error_component_selector),\n            no_data=self.no_data or no_data,\n        )\n\n    def page(\n        self,\n        component_selector: HTMYComponentSelector[T],\n        *,\n        error_component_selector: HTMYComponentSelector[Exception] | None = None,\n    ) -&gt; Callable[[MaybeAsyncFunc[P, T]], Callable[P, Coroutine[None, None, T | Response]]]:\n        \"\"\"\n        Decorator for rendering a route's result.\n\n        This decorator triggers HTML rendering regardless of whether the request was HTMX or not.\n\n        Arguments:\n            component_selector: The component selector to use.\n            error_component_selector: The component selector to use for route error rendering.\n        \"\"\"\n        return page(\n            self._make_render_function(component_selector),\n            render_error=None\n            if error_component_selector is None\n            else self._make_error_render_function(error_component_selector),\n        )\n\n    async def render_component(self, component: h.Component, request: Request) -&gt; str:\n        \"\"\"\n        Renders the given component.\n\n        This method is useful for rendering components directly, outside of the context of a route\n        (meaning no access to route parameters), for example in exception handlers.\n\n        The method adds all the usual data to the `htmy` rendering context, including the result of\n        all request processors. There is no access to route parameters though, so while `RouteParams`\n        will be in the context, it will be empty.\n\n        Arguments:\n            component: The component to render.\n            request: The current request.\n\n        Returns:\n            The rendered component.\n        \"\"\"\n        return await self.htmy.render(component, self._make_render_context(request, {}))\n\n    def _make_render_function(self, component_selector: HTMYComponentSelector[T]) -&gt; HTMLRenderer[T]:\n        \"\"\"\n        Creates a render function that uses the given component selector.\n        \"\"\"\n\n        async def render(result: T, *, context: dict[str, Any], request: Request) -&gt; str:\n            component = (\n                component_selector.get_component(request, None)\n                if isinstance(component_selector, RequestComponentSelector)\n                else component_selector\n            )\n            return await self.htmy.render(component(result), self._make_render_context(request, context))\n\n        return render\n\n    def _make_error_render_function(\n        self, component_selector: HTMYComponentSelector[Exception]\n    ) -&gt; HTMLRenderer[Exception]:\n        \"\"\"\n        Creates an error renderer function that uses the given component selector.\n        \"\"\"\n\n        async def render(result: Exception, *, context: dict[str, Any], request: Request) -&gt; str:\n            component = (\n                component_selector.get_component(request, result)\n                if isinstance(component_selector, RequestComponentSelector)\n                else component_selector\n            )\n            return await self.htmy.render(component(result), self._make_render_context(request, context))\n\n        return render\n\n    def _make_render_context(self, request: Request, route_params: dict[str, Any]) -&gt; h.Context:\n        \"\"\"\n        Creates the `htmy` rendering context for the given request and route parameters.\n\n        Arguments:\n            request: The current request.\n            route_params: The route parameters.\n\n        Returns:\n            The `htmy` rendering context.\n        \"\"\"\n        # Add the current request to the context.\n        result = CurrentRequest.to_context(request)\n\n        # Add all route params to the context.\n        result.update(RouteParams(route_params).to_context())\n\n        # Run all request processors and add the result to the context.\n        for cp in self.request_processors:\n            result.update(cp(request))\n\n        return result\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.HTMY.htmy","title":"<code>htmy = field(default_factory=h.Renderer)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The HTMY renderer to use.</p>"},{"location":"api/htmy/#fasthx.htmy.HTMY.no_data","title":"<code>no_data = field(default=False, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, <code>hx()</code> routes will only accept HTMX requests.</p> <p>Note that if this property is <code>True</code>, then the <code>hx()</code> decorator's <code>no_data</code> argument will have no effect.</p>"},{"location":"api/htmy/#fasthx.htmy.HTMY.request_processors","title":"<code>request_processors = field(default_factory=list, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A list of functions that expect the current request and return an <code>htmy</code> <code>Context</code> that should be used during rendering in addition to the default context of <code>self.htmy</code>.</p>"},{"location":"api/htmy/#fasthx.htmy.HTMY.hx","title":"<code>hx(component_selector, *, error_component_selector=None, no_data=False)</code>","text":"<p>Decorator for rendering the route's result if the request was an HTMX one.</p> <p>Parameters:</p> Name Type Description Default <code>component_selector</code> <code>HTMYComponentSelector[T]</code> <p>The component selector to use.</p> required <code>error_component_selector</code> <code>HTMYComponentSelector[Exception] | None</code> <p>The component selector to use for route error rendering.</p> <code>None</code> <code>no_data</code> <code>bool</code> <p>If set, the route will only accept HTMX requests.</p> <code>False</code> Source code in <code>fasthx/htmy.py</code> <pre><code>def hx(\n    self,\n    component_selector: HTMYComponentSelector[T],\n    *,\n    error_component_selector: HTMYComponentSelector[Exception] | None = None,\n    no_data: bool = False,\n) -&gt; Callable[[MaybeAsyncFunc[P, T]], Callable[P, Coroutine[None, None, T | Response]]]:\n    \"\"\"\n    Decorator for rendering the route's result if the request was an HTMX one.\n\n    Arguments:\n        component_selector: The component selector to use.\n        error_component_selector: The component selector to use for route error rendering.\n        no_data: If set, the route will only accept HTMX requests.\n    \"\"\"\n    return hx(\n        self._make_render_function(component_selector),\n        render_error=None\n        if error_component_selector is None\n        else self._make_error_render_function(error_component_selector),\n        no_data=self.no_data or no_data,\n    )\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.HTMY.page","title":"<code>page(component_selector, *, error_component_selector=None)</code>","text":"<p>Decorator for rendering a route's result.</p> <p>This decorator triggers HTML rendering regardless of whether the request was HTMX or not.</p> <p>Parameters:</p> Name Type Description Default <code>component_selector</code> <code>HTMYComponentSelector[T]</code> <p>The component selector to use.</p> required <code>error_component_selector</code> <code>HTMYComponentSelector[Exception] | None</code> <p>The component selector to use for route error rendering.</p> <code>None</code> Source code in <code>fasthx/htmy.py</code> <pre><code>def page(\n    self,\n    component_selector: HTMYComponentSelector[T],\n    *,\n    error_component_selector: HTMYComponentSelector[Exception] | None = None,\n) -&gt; Callable[[MaybeAsyncFunc[P, T]], Callable[P, Coroutine[None, None, T | Response]]]:\n    \"\"\"\n    Decorator for rendering a route's result.\n\n    This decorator triggers HTML rendering regardless of whether the request was HTMX or not.\n\n    Arguments:\n        component_selector: The component selector to use.\n        error_component_selector: The component selector to use for route error rendering.\n    \"\"\"\n    return page(\n        self._make_render_function(component_selector),\n        render_error=None\n        if error_component_selector is None\n        else self._make_error_render_function(error_component_selector),\n    )\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.HTMY.render_component","title":"<code>render_component(component, request)</code>  <code>async</code>","text":"<p>Renders the given component.</p> <p>This method is useful for rendering components directly, outside of the context of a route (meaning no access to route parameters), for example in exception handlers.</p> <p>The method adds all the usual data to the <code>htmy</code> rendering context, including the result of all request processors. There is no access to route parameters though, so while <code>RouteParams</code> will be in the context, it will be empty.</p> <p>Parameters:</p> Name Type Description Default <code>component</code> <code>Component</code> <p>The component to render.</p> required <code>request</code> <code>Request</code> <p>The current request.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The rendered component.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>async def render_component(self, component: h.Component, request: Request) -&gt; str:\n    \"\"\"\n    Renders the given component.\n\n    This method is useful for rendering components directly, outside of the context of a route\n    (meaning no access to route parameters), for example in exception handlers.\n\n    The method adds all the usual data to the `htmy` rendering context, including the result of\n    all request processors. There is no access to route parameters though, so while `RouteParams`\n    will be in the context, it will be empty.\n\n    Arguments:\n        component: The component to render.\n        request: The current request.\n\n    Returns:\n        The rendered component.\n    \"\"\"\n    return await self.htmy.render(component, self._make_render_context(request, {}))\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.RouteParams","title":"<code>RouteParams</code>  <code>dataclass</code>","text":"<p>HTMY context aware utility for accessing route parameters (resolved dependencies).</p> <p>For convenience, it is a partial, readonly mapping implementation. Supported mapping methods: <code>__contains__</code>, <code>__getitem___()</code>, and <code>get()</code>. For more complex use-cases, you can rely on the <code>params</code> property.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass RouteParams:\n    \"\"\"\n    HTMY context aware utility for accessing route parameters (resolved dependencies).\n\n    For convenience, it is a partial, readonly mapping implementation. Supported mapping methods:\n    `__contains__`, `__getitem___()`, and `get()`. For more complex use-cases, you can rely on the\n    `params` property.\n    \"\"\"\n\n    params: dict[str, Any]\n    \"\"\"Route parameters.\"\"\"\n\n    def __contains__(self, key: str) -&gt; bool:\n        \"\"\"Membership test operator (`in`).\"\"\"\n        return key in self.params\n\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"`self[key]` implementation.\"\"\"\n        return self.params[key]\n\n    def get(self, key: str, default: Any = None, /) -&gt; Any:\n        \"\"\"Returns the parameter with the given key.\"\"\"\n        return self.params.get(key, default)\n\n    def to_context(self) -&gt; h.MutableContext:\n        \"\"\"Creates an `htmy` `Context` for this instance.\"\"\"\n        return {RouteParams: self}\n\n    @classmethod\n    def from_context(cls, context: h.Context) -&gt; Self:\n        \"\"\"\n        Loads the `RouteParams` instance from the given context.\n\n        Raises:\n            KeyError: If there's no `RouteParams` in the context.\n            TypeError: If invalid data is stored for `RouteParams`.\n        \"\"\"\n        result = context[cls]\n        if isinstance(result, cls):\n            return result\n\n        raise TypeError(f\"Invalid context data type for {cls.__name__}.\")\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.RouteParams.params","title":"<code>params</code>  <code>instance-attribute</code>","text":"<p>Route parameters.</p>"},{"location":"api/htmy/#fasthx.htmy.RouteParams.__contains__","title":"<code>__contains__(key)</code>","text":"<p>Membership test operator (<code>in</code>).</p> Source code in <code>fasthx/htmy.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    \"\"\"Membership test operator (`in`).\"\"\"\n    return key in self.params\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.RouteParams.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p><code>self[key]</code> implementation.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Any:\n    \"\"\"`self[key]` implementation.\"\"\"\n    return self.params[key]\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.RouteParams.from_context","title":"<code>from_context(context)</code>  <code>classmethod</code>","text":"<p>Loads the <code>RouteParams</code> instance from the given context.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If there's no <code>RouteParams</code> in the context.</p> <code>TypeError</code> <p>If invalid data is stored for <code>RouteParams</code>.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>@classmethod\ndef from_context(cls, context: h.Context) -&gt; Self:\n    \"\"\"\n    Loads the `RouteParams` instance from the given context.\n\n    Raises:\n        KeyError: If there's no `RouteParams` in the context.\n        TypeError: If invalid data is stored for `RouteParams`.\n    \"\"\"\n    result = context[cls]\n    if isinstance(result, cls):\n        return result\n\n    raise TypeError(f\"Invalid context data type for {cls.__name__}.\")\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.RouteParams.get","title":"<code>get(key, default=None)</code>","text":"<p>Returns the parameter with the given key.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>def get(self, key: str, default: Any = None, /) -&gt; Any:\n    \"\"\"Returns the parameter with the given key.\"\"\"\n    return self.params.get(key, default)\n</code></pre>"},{"location":"api/htmy/#fasthx.htmy.RouteParams.to_context","title":"<code>to_context()</code>","text":"<p>Creates an <code>htmy</code> <code>Context</code> for this instance.</p> Source code in <code>fasthx/htmy.py</code> <pre><code>def to_context(self) -&gt; h.MutableContext:\n    \"\"\"Creates an `htmy` `Context` for this instance.\"\"\"\n    return {RouteParams: self}\n</code></pre>"},{"location":"api/jinja/","title":"<code>Jinja</code>","text":""},{"location":"api/jinja/#fasthx.Jinja","title":"<code>fasthx.Jinja</code>  <code>dataclass</code>","text":"<p>Jinja2 renderer utility with FastAPI route decorators.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass Jinja:\n    \"\"\"Jinja2 renderer utility with FastAPI route decorators.\"\"\"\n\n    templates: Jinja2Templates\n    \"\"\"The Jinja2 templates of the application.\"\"\"\n\n    make_context: JinjaContextFactory = JinjaContext.unpack_result\n    \"\"\"\n    Function that will be used by default to convert a route's return value into\n    a Jinja rendering context. The default value is `JinjaContext.unpack_result`.\n    \"\"\"\n\n    no_data: bool = field(default=False, kw_only=True)\n    \"\"\"\n    If set, `hx()` routes will only accept HTMX requests.\n\n    Note that if this property is `True`, then the `hx()` decorator's `no_data` argument\n    will have no effect.\n    \"\"\"\n\n    def hx(\n        self,\n        template: ComponentSelector[str],\n        *,\n        error_template: ComponentSelector[str] | None = None,\n        make_context: JinjaContextFactory | None = None,\n        no_data: bool = False,\n        prefix: str | None = None,\n    ) -&gt; Callable[[MaybeAsyncFunc[P, Any]], Callable[P, Coroutine[None, None, Any | Response]]]:\n        \"\"\"\n        Decorator for rendering a route's result if the request was an HTMX one.\n\n        Arguments:\n            template: The Jinja2 template selector to use.\n            error_template: The Jinja2 template selector to use for route error rendering.\n            make_context: Route-specific override for the `make_context` property.\n            no_data: If set, the route will only accept HTMX requests.\n            prefix: Optional template name prefix.\n\n        Returns:\n            The rendered HTML for HTMX requests, otherwise the route's unchanged return value.\n        \"\"\"\n        if make_context is None:\n            # No route-specific override.\n            make_context = self.make_context\n\n        return hx(\n            self._make_render_function(template, make_context=make_context, prefix=prefix),\n            render_error=None\n            if error_template is None\n            else self._make_render_function(\n                error_template, make_context=make_context, prefix=prefix, error_renderer=True\n            ),\n            no_data=self.no_data or no_data,\n        )\n\n    def page(\n        self,\n        template: ComponentSelector[str],\n        *,\n        error_template: ComponentSelector[str] | None = None,\n        make_context: JinjaContextFactory | None = None,\n        prefix: str | None = None,\n    ) -&gt; Callable[[MaybeAsyncFunc[P, Any]], Callable[P, Coroutine[None, None, Any | Response]]]:\n        \"\"\"\n        Decorator for rendering a route's result.\n\n        This decorator triggers HTML rendering regardless of whether the request was HTMX or not.\n\n        Arguments:\n            template: The Jinja2 template selector to use.\n            error_template: The Jinja2 template selector to use for route error rendering.\n            make_context: Route-specific override for the `make_context` property.\n            prefix: Optional template name prefix.\n        \"\"\"\n        if make_context is None:\n            # No route-specific override.\n            make_context = self.make_context\n\n        return page(\n            self._make_render_function(template, make_context=make_context, prefix=prefix),\n            render_error=None\n            if error_template is None\n            else self._make_render_function(\n                error_template, make_context=make_context, prefix=prefix, error_renderer=True\n            ),\n        )\n\n    def _make_render_function(\n        self,\n        template: ComponentSelector[str],\n        *,\n        make_context: JinjaContextFactory,\n        prefix: str | None,\n        error_renderer: bool = False,\n    ) -&gt; HTMLRenderer[Any]:\n        \"\"\"\n        Creates an `HTMLRenderer` with the given configuration.\n\n        Arguments:\n            template: The template the renderer function should use.\n            make_context: The Jinja rendering context factory to use.\n            prefix: Optional template name prefix.\n            error_renderer: Whether this is an error renderer creation.\n        \"\"\"\n\n        def render(result: Any, *, context: dict[str, Any], request: Request) -&gt; str | Response:\n            template_name = self._resolve_template_name(\n                template,\n                error=result if error_renderer else None,\n                prefix=prefix,\n                request=request,\n            )\n            return self._make_response(\n                template_name,\n                jinja_context=make_context(route_result=result, route_context=context),\n                request=request,\n            )\n\n        return render\n\n    def _make_response(\n        self,\n        template: str,\n        *,\n        jinja_context: dict[str, Any],\n        request: Request,\n    ) -&gt; str | Response:\n        \"\"\"\n        Creates the HTML response using the given Jinja template name and context.\n\n        Arguments:\n            template: The Jinja2 template selector to use.\n            jinja_context: The Jinj2 rendering context.\n            prefix: Optional template name prefix.\n            request: The current request.\n        \"\"\"\n        # The reason for returning string from this method is to let `hx()` or `page()` create\n        # the HTML response - that way they can copy response headers and do other convenience\n        # conversions.\n        # The drawback is that users lose some of the baked-in debug utilities of TemplateResponse.\n        # This can be worked around by using a rendering context factory that includes the route's\n        # dependencies in the Jinja context. Then this method can be overridden to take the Response\n        # object from the context and copy the header from it into TemplateResponse.\n        result = self.templates.TemplateResponse(\n            name=template,\n            context=jinja_context,\n            request=request,\n        )\n        return bytes(result.body).decode(result.charset)\n\n    def _resolve_template_name(\n        self,\n        template: ComponentSelector[str],\n        *,\n        error: Exception | None = None,\n        prefix: str | None,\n        request: Request,\n    ) -&gt; str:\n        \"\"\"\n        Resolves the template selector into a full template name.\n\n        Arguments:\n            template: The template selector.\n            error: The error raised by the route.\n            prefix: Optional template name prefix.\n            request: The current request.\n\n        Returns:\n            The resolved, full template name.\n\n        Raises:\n            ValueError: If template resolution failed.\n        \"\"\"\n        if isinstance(template, RequestComponentSelector):\n            try:\n                result = template.get_component(request, error)\n            except KeyError as e:\n                raise ValueError(\"Failed to resolve template name from request.\") from e\n        elif isinstance(template, str):\n            result = template\n        else:\n            raise ValueError(\"Unknown template selector.\")\n\n        prefix = None if isinstance(result, JinjaPath) else prefix\n        result = result.lstrip(\"/\")\n        return f\"{prefix}/{result}\" if prefix else result\n</code></pre>"},{"location":"api/jinja/#fasthx.Jinja.make_context","title":"<code>make_context = JinjaContext.unpack_result</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Function that will be used by default to convert a route's return value into a Jinja rendering context. The default value is <code>JinjaContext.unpack_result</code>.</p>"},{"location":"api/jinja/#fasthx.Jinja.no_data","title":"<code>no_data = field(default=False, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If set, <code>hx()</code> routes will only accept HTMX requests.</p> <p>Note that if this property is <code>True</code>, then the <code>hx()</code> decorator's <code>no_data</code> argument will have no effect.</p>"},{"location":"api/jinja/#fasthx.Jinja.templates","title":"<code>templates</code>  <code>instance-attribute</code>","text":"<p>The Jinja2 templates of the application.</p>"},{"location":"api/jinja/#fasthx.Jinja.hx","title":"<code>hx(template, *, error_template=None, make_context=None, no_data=False, prefix=None)</code>","text":"<p>Decorator for rendering a route's result if the request was an HTMX one.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>ComponentSelector[str]</code> <p>The Jinja2 template selector to use.</p> required <code>error_template</code> <code>ComponentSelector[str] | None</code> <p>The Jinja2 template selector to use for route error rendering.</p> <code>None</code> <code>make_context</code> <code>JinjaContextFactory | None</code> <p>Route-specific override for the <code>make_context</code> property.</p> <code>None</code> <code>no_data</code> <code>bool</code> <p>If set, the route will only accept HTMX requests.</p> <code>False</code> <code>prefix</code> <code>str | None</code> <p>Optional template name prefix.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[MaybeAsyncFunc[P, Any]], Callable[P, Coroutine[None, None, Any | Response]]]</code> <p>The rendered HTML for HTMX requests, otherwise the route's unchanged return value.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>def hx(\n    self,\n    template: ComponentSelector[str],\n    *,\n    error_template: ComponentSelector[str] | None = None,\n    make_context: JinjaContextFactory | None = None,\n    no_data: bool = False,\n    prefix: str | None = None,\n) -&gt; Callable[[MaybeAsyncFunc[P, Any]], Callable[P, Coroutine[None, None, Any | Response]]]:\n    \"\"\"\n    Decorator for rendering a route's result if the request was an HTMX one.\n\n    Arguments:\n        template: The Jinja2 template selector to use.\n        error_template: The Jinja2 template selector to use for route error rendering.\n        make_context: Route-specific override for the `make_context` property.\n        no_data: If set, the route will only accept HTMX requests.\n        prefix: Optional template name prefix.\n\n    Returns:\n        The rendered HTML for HTMX requests, otherwise the route's unchanged return value.\n    \"\"\"\n    if make_context is None:\n        # No route-specific override.\n        make_context = self.make_context\n\n    return hx(\n        self._make_render_function(template, make_context=make_context, prefix=prefix),\n        render_error=None\n        if error_template is None\n        else self._make_render_function(\n            error_template, make_context=make_context, prefix=prefix, error_renderer=True\n        ),\n        no_data=self.no_data or no_data,\n    )\n</code></pre>"},{"location":"api/jinja/#fasthx.Jinja.page","title":"<code>page(template, *, error_template=None, make_context=None, prefix=None)</code>","text":"<p>Decorator for rendering a route's result.</p> <p>This decorator triggers HTML rendering regardless of whether the request was HTMX or not.</p> <p>Parameters:</p> Name Type Description Default <code>template</code> <code>ComponentSelector[str]</code> <p>The Jinja2 template selector to use.</p> required <code>error_template</code> <code>ComponentSelector[str] | None</code> <p>The Jinja2 template selector to use for route error rendering.</p> <code>None</code> <code>make_context</code> <code>JinjaContextFactory | None</code> <p>Route-specific override for the <code>make_context</code> property.</p> <code>None</code> <code>prefix</code> <code>str | None</code> <p>Optional template name prefix.</p> <code>None</code> Source code in <code>fasthx/jinja.py</code> <pre><code>def page(\n    self,\n    template: ComponentSelector[str],\n    *,\n    error_template: ComponentSelector[str] | None = None,\n    make_context: JinjaContextFactory | None = None,\n    prefix: str | None = None,\n) -&gt; Callable[[MaybeAsyncFunc[P, Any]], Callable[P, Coroutine[None, None, Any | Response]]]:\n    \"\"\"\n    Decorator for rendering a route's result.\n\n    This decorator triggers HTML rendering regardless of whether the request was HTMX or not.\n\n    Arguments:\n        template: The Jinja2 template selector to use.\n        error_template: The Jinja2 template selector to use for route error rendering.\n        make_context: Route-specific override for the `make_context` property.\n        prefix: Optional template name prefix.\n    \"\"\"\n    if make_context is None:\n        # No route-specific override.\n        make_context = self.make_context\n\n    return page(\n        self._make_render_function(template, make_context=make_context, prefix=prefix),\n        render_error=None\n        if error_template is None\n        else self._make_render_function(\n            error_template, make_context=make_context, prefix=prefix, error_renderer=True\n        ),\n    )\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContext","title":"<code>fasthx.JinjaContext</code>","text":"<p>Core <code>JinjaContextFactory</code> implementations.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>class JinjaContext:\n    \"\"\"\n    Core `JinjaContextFactory` implementations.\n    \"\"\"\n\n    @classmethod\n    def unpack_object(cls, obj: Any) -&gt; dict[str, Any]:\n        \"\"\"\n        Utility function that unpacks an object into a `dict`.\n\n        Supports `dict` and `Collection` instances, plus anything with `__dict__` or `__slots__`\n        attributes, for example Pydantic models, dataclasses, or \"standard\" class instances.\n\n        Conversion rules:\n\n        - `dict`: returned as is.\n        - `Collection`: returned as `{\"items\": obj}`, available in templates as `items`.\n        - Objects with `__dict__` or `__slots__`: known keys are taken from `__dict__` or `__slots__`\n          and the context will be created as `{key: getattr(route_result, key) for key in keys}`,\n          omitting property names starting with an underscore. For Pydantic models, computed\n          fields will also be included.\n        - `None` is converted into an empty context.\n\n        Raises:\n            ValueError: If the given object can not be handled by any of the conversion rules.\n        \"\"\"\n        if isinstance(obj, dict):\n            return obj\n\n        # Covers lists, tuples, sets, etc..\n        if isinstance(obj, Collection):\n            return {\"items\": obj}\n\n        object_keys: Iterable[str] | None = None\n\n        # __dict__ should take priority if an object has both this and __slots__.\n        if hasattr(obj, \"__dict__\"):\n            # Covers Pydantic models and standard classes.\n            object_keys = obj.__dict__.keys()\n            cls = type(obj)\n            if hasattr(cls, \"model_computed_fields\"):  # Pydantic computed fields support.\n                object_keys = [\n                    *(() if object_keys is None else object_keys),\n                    *cls.model_computed_fields,\n                ]\n        elif hasattr(obj, \"__slots__\"):\n            # Covers classes with with __slots__.\n            object_keys = obj.__slots__\n\n        if object_keys is not None:\n            return {key: getattr(obj, key) for key in object_keys if not key.startswith(\"_\")}\n\n        if obj is None:\n            # Convert no response to empty context.\n            return {}\n\n        raise ValueError(\"Result conversion failed, unknown result type.\")\n\n    @classmethod\n    def unpack_result(cls, *, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"\n        Jinja context factory that tries to reasonably convert non-`dict` route results\n        to valid Jinja contexts (the `route_context` argument is ignored).\n\n        Supports everything that `JinjaContext.unpack_object()` does and follows the same\n        conversion rules.\n\n        Raises:\n            ValueError: If `route_result` can not be handled by any of the conversion rules.\n        \"\"\"\n        return cls.unpack_object(route_result)\n\n    @classmethod\n    def unpack_result_with_route_context(\n        cls,\n        *,\n        route_result: Any,\n        route_context: dict[str, Any],\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Jinja context factory that tries to reasonably convert non-`dict` route results\n        to valid Jinja contexts, also including every key-value pair from `route_context`.\n\n        Supports everything that `JinjaContext.unpack_object()` does and follows the same\n        conversion rules.\n\n        Raises:\n            ValueError: If `JinjaContext.unpack_result()` raises an error or if there's\n                a key conflict between `route_result` and `route_context`.\n        \"\"\"\n        result = cls.unpack_result(route_result=route_result, route_context=route_context)\n        if len(set(result.keys()) &amp; set(route_context.keys())) &gt; 0:\n            raise ValueError(\"Overlapping keys in route result and route context.\")\n\n        # route_context is the keyword args of the route collected into a dict. Update and\n        # return this dict rather than result, as the result might be the same object that\n        # was returned by the route and someone may have a reference to it.\n        route_context.update(result)\n        return route_context\n\n    @classmethod\n    def use_converters(\n        cls,\n        convert_route_result: Callable[[Any], dict[str, Any]] | None,\n        convert_route_context: Callable[[dict[str, Any]], dict[str, Any]] | None = None,\n    ) -&gt; JinjaContextFactory:\n        \"\"\"\n        Creates a `JinjaContextFactory` that uses the provided functions to convert\n        `route_result` and `route_context` to a Jinja context.\n\n        The returned `JinjaContextFactory` raises a `ValueError` if the overlapping keys are found.\n\n        Arguments:\n            convert_route_result: Function that takes `route_result` and converts it into a `dict`.\n                See `JinjaContextFactory` for `route_result` details.\n            convert_route_context: Function that takes `route_context` and converts it into a `dict`.\n                See `JinjaContextFactory` for `route_context` details.\n\n        Returns:\n            The created `JinjaContextFactory`.\n        \"\"\"\n\n        def make_jinja_context(*, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n            rr = {} if convert_route_result is None else convert_route_result(route_result)\n            rc = {} if convert_route_context is None else convert_route_context(route_context)\n            if len(set(rr.keys()) &amp; set(rc.keys())) &gt; 0:\n                raise ValueError(\"Overlapping keys in route result and route context.\")\n\n            rr.update(rc)\n            return rr\n\n        return make_jinja_context\n\n    @classmethod\n    @lru_cache\n    def wrap_as(cls, result_key: str, context_key: str | None = None) -&gt; JinjaContextFactory:\n        \"\"\"\n        Creates a `JinjaContextFactory` that wraps the route's result and optionally the route\n        context under user-specified keys.\n\n        `result_key` and `context_key` must be different.\n\n        Arguments:\n            result_key: The key by which the `route_result` should be accessible in templates.\n                See `JinjaContextFactory` for `route_result` details.\n            context_key: The key by whih the `route_context` should be accessible in templates.\n                If `None` (the default), then the `route_context` will not be accessible.\n                See `JinjaContextFactory` for `route_context` details.\n\n        Returns:\n            The created `JinjaContextFactory`.\n\n        Raises:\n            ValueError: If `result_key` and `context_key` are equal.\n        \"\"\"\n\n        if result_key == context_key:\n            raise ValueError(\"The two keys must be different, merging is not supported.\")\n\n        def wrap(*, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n            result = {result_key: route_result}\n            if context_key is not None:\n                result[context_key] = route_context\n\n            return result\n\n        return wrap\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContext.unpack_object","title":"<code>unpack_object(obj)</code>  <code>classmethod</code>","text":"<p>Utility function that unpacks an object into a <code>dict</code>.</p> <p>Supports <code>dict</code> and <code>Collection</code> instances, plus anything with <code>__dict__</code> or <code>__slots__</code> attributes, for example Pydantic models, dataclasses, or \"standard\" class instances.</p> <p>Conversion rules:</p> <ul> <li><code>dict</code>: returned as is.</li> <li><code>Collection</code>: returned as <code>{\"items\": obj}</code>, available in templates as <code>items</code>.</li> <li>Objects with <code>__dict__</code> or <code>__slots__</code>: known keys are taken from <code>__dict__</code> or <code>__slots__</code>   and the context will be created as <code>{key: getattr(route_result, key) for key in keys}</code>,   omitting property names starting with an underscore. For Pydantic models, computed   fields will also be included.</li> <li><code>None</code> is converted into an empty context.</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given object can not be handled by any of the conversion rules.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>@classmethod\ndef unpack_object(cls, obj: Any) -&gt; dict[str, Any]:\n    \"\"\"\n    Utility function that unpacks an object into a `dict`.\n\n    Supports `dict` and `Collection` instances, plus anything with `__dict__` or `__slots__`\n    attributes, for example Pydantic models, dataclasses, or \"standard\" class instances.\n\n    Conversion rules:\n\n    - `dict`: returned as is.\n    - `Collection`: returned as `{\"items\": obj}`, available in templates as `items`.\n    - Objects with `__dict__` or `__slots__`: known keys are taken from `__dict__` or `__slots__`\n      and the context will be created as `{key: getattr(route_result, key) for key in keys}`,\n      omitting property names starting with an underscore. For Pydantic models, computed\n      fields will also be included.\n    - `None` is converted into an empty context.\n\n    Raises:\n        ValueError: If the given object can not be handled by any of the conversion rules.\n    \"\"\"\n    if isinstance(obj, dict):\n        return obj\n\n    # Covers lists, tuples, sets, etc..\n    if isinstance(obj, Collection):\n        return {\"items\": obj}\n\n    object_keys: Iterable[str] | None = None\n\n    # __dict__ should take priority if an object has both this and __slots__.\n    if hasattr(obj, \"__dict__\"):\n        # Covers Pydantic models and standard classes.\n        object_keys = obj.__dict__.keys()\n        cls = type(obj)\n        if hasattr(cls, \"model_computed_fields\"):  # Pydantic computed fields support.\n            object_keys = [\n                *(() if object_keys is None else object_keys),\n                *cls.model_computed_fields,\n            ]\n    elif hasattr(obj, \"__slots__\"):\n        # Covers classes with with __slots__.\n        object_keys = obj.__slots__\n\n    if object_keys is not None:\n        return {key: getattr(obj, key) for key in object_keys if not key.startswith(\"_\")}\n\n    if obj is None:\n        # Convert no response to empty context.\n        return {}\n\n    raise ValueError(\"Result conversion failed, unknown result type.\")\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContext.unpack_result","title":"<code>unpack_result(*, route_result, route_context)</code>  <code>classmethod</code>","text":"<p>Jinja context factory that tries to reasonably convert non-<code>dict</code> route results to valid Jinja contexts (the <code>route_context</code> argument is ignored).</p> <p>Supports everything that <code>JinjaContext.unpack_object()</code> does and follows the same conversion rules.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>route_result</code> can not be handled by any of the conversion rules.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>@classmethod\ndef unpack_result(cls, *, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Jinja context factory that tries to reasonably convert non-`dict` route results\n    to valid Jinja contexts (the `route_context` argument is ignored).\n\n    Supports everything that `JinjaContext.unpack_object()` does and follows the same\n    conversion rules.\n\n    Raises:\n        ValueError: If `route_result` can not be handled by any of the conversion rules.\n    \"\"\"\n    return cls.unpack_object(route_result)\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContext.unpack_result_with_route_context","title":"<code>unpack_result_with_route_context(*, route_result, route_context)</code>  <code>classmethod</code>","text":"<p>Jinja context factory that tries to reasonably convert non-<code>dict</code> route results to valid Jinja contexts, also including every key-value pair from <code>route_context</code>.</p> <p>Supports everything that <code>JinjaContext.unpack_object()</code> does and follows the same conversion rules.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>JinjaContext.unpack_result()</code> raises an error or if there's a key conflict between <code>route_result</code> and <code>route_context</code>.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>@classmethod\ndef unpack_result_with_route_context(\n    cls,\n    *,\n    route_result: Any,\n    route_context: dict[str, Any],\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Jinja context factory that tries to reasonably convert non-`dict` route results\n    to valid Jinja contexts, also including every key-value pair from `route_context`.\n\n    Supports everything that `JinjaContext.unpack_object()` does and follows the same\n    conversion rules.\n\n    Raises:\n        ValueError: If `JinjaContext.unpack_result()` raises an error or if there's\n            a key conflict between `route_result` and `route_context`.\n    \"\"\"\n    result = cls.unpack_result(route_result=route_result, route_context=route_context)\n    if len(set(result.keys()) &amp; set(route_context.keys())) &gt; 0:\n        raise ValueError(\"Overlapping keys in route result and route context.\")\n\n    # route_context is the keyword args of the route collected into a dict. Update and\n    # return this dict rather than result, as the result might be the same object that\n    # was returned by the route and someone may have a reference to it.\n    route_context.update(result)\n    return route_context\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContext.use_converters","title":"<code>use_converters(convert_route_result, convert_route_context=None)</code>  <code>classmethod</code>","text":"<p>Creates a <code>JinjaContextFactory</code> that uses the provided functions to convert <code>route_result</code> and <code>route_context</code> to a Jinja context.</p> <p>The returned <code>JinjaContextFactory</code> raises a <code>ValueError</code> if the overlapping keys are found.</p> <p>Parameters:</p> Name Type Description Default <code>convert_route_result</code> <code>Callable[[Any], dict[str, Any]] | None</code> <p>Function that takes <code>route_result</code> and converts it into a <code>dict</code>. See <code>JinjaContextFactory</code> for <code>route_result</code> details.</p> required <code>convert_route_context</code> <code>Callable[[dict[str, Any]], dict[str, Any]] | None</code> <p>Function that takes <code>route_context</code> and converts it into a <code>dict</code>. See <code>JinjaContextFactory</code> for <code>route_context</code> details.</p> <code>None</code> <p>Returns:</p> Type Description <code>JinjaContextFactory</code> <p>The created <code>JinjaContextFactory</code>.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>@classmethod\ndef use_converters(\n    cls,\n    convert_route_result: Callable[[Any], dict[str, Any]] | None,\n    convert_route_context: Callable[[dict[str, Any]], dict[str, Any]] | None = None,\n) -&gt; JinjaContextFactory:\n    \"\"\"\n    Creates a `JinjaContextFactory` that uses the provided functions to convert\n    `route_result` and `route_context` to a Jinja context.\n\n    The returned `JinjaContextFactory` raises a `ValueError` if the overlapping keys are found.\n\n    Arguments:\n        convert_route_result: Function that takes `route_result` and converts it into a `dict`.\n            See `JinjaContextFactory` for `route_result` details.\n        convert_route_context: Function that takes `route_context` and converts it into a `dict`.\n            See `JinjaContextFactory` for `route_context` details.\n\n    Returns:\n        The created `JinjaContextFactory`.\n    \"\"\"\n\n    def make_jinja_context(*, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n        rr = {} if convert_route_result is None else convert_route_result(route_result)\n        rc = {} if convert_route_context is None else convert_route_context(route_context)\n        if len(set(rr.keys()) &amp; set(rc.keys())) &gt; 0:\n            raise ValueError(\"Overlapping keys in route result and route context.\")\n\n        rr.update(rc)\n        return rr\n\n    return make_jinja_context\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContext.wrap_as","title":"<code>wrap_as(result_key, context_key=None)</code>  <code>cached</code> <code>classmethod</code>","text":"<p>Creates a <code>JinjaContextFactory</code> that wraps the route's result and optionally the route context under user-specified keys.</p> <p><code>result_key</code> and <code>context_key</code> must be different.</p> <p>Parameters:</p> Name Type Description Default <code>result_key</code> <code>str</code> <p>The key by which the <code>route_result</code> should be accessible in templates. See <code>JinjaContextFactory</code> for <code>route_result</code> details.</p> required <code>context_key</code> <code>str | None</code> <p>The key by whih the <code>route_context</code> should be accessible in templates. If <code>None</code> (the default), then the <code>route_context</code> will not be accessible. See <code>JinjaContextFactory</code> for <code>route_context</code> details.</p> <code>None</code> <p>Returns:</p> Type Description <code>JinjaContextFactory</code> <p>The created <code>JinjaContextFactory</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>result_key</code> and <code>context_key</code> are equal.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>@classmethod\n@lru_cache\ndef wrap_as(cls, result_key: str, context_key: str | None = None) -&gt; JinjaContextFactory:\n    \"\"\"\n    Creates a `JinjaContextFactory` that wraps the route's result and optionally the route\n    context under user-specified keys.\n\n    `result_key` and `context_key` must be different.\n\n    Arguments:\n        result_key: The key by which the `route_result` should be accessible in templates.\n            See `JinjaContextFactory` for `route_result` details.\n        context_key: The key by whih the `route_context` should be accessible in templates.\n            If `None` (the default), then the `route_context` will not be accessible.\n            See `JinjaContextFactory` for `route_context` details.\n\n    Returns:\n        The created `JinjaContextFactory`.\n\n    Raises:\n        ValueError: If `result_key` and `context_key` are equal.\n    \"\"\"\n\n    if result_key == context_key:\n        raise ValueError(\"The two keys must be different, merging is not supported.\")\n\n    def wrap(*, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n        result = {result_key: route_result}\n        if context_key is not None:\n            result[context_key] = route_context\n\n        return result\n\n    return wrap\n</code></pre>"},{"location":"api/jinja/#fasthx.TemplateHeader","title":"<code>fasthx.TemplateHeader</code>  <code>dataclass</code>","text":"<p>Template selector that takes the Jinja template name from a request header.</p> <p>This class makes it possible for the client to submit the key/ID of the required template to the server in a header. The Jinja decorators will then look up and render the requested template if it exists. If the client doesn't request a specific template, then <code>default</code> will be used if it was set, otherwise an exception will be raised.</p> <p>By default this class treats template keys as case-insensitive. If you'd like to disable this behavior, set <code>case_sensitive</code> to <code>True</code>.</p> <p>This class can also handle route errors if the <code>error</code> property is set.</p> Implements <ul> <li><code>RequestComponentSelector[str]</code>.</li> </ul> Source code in <code>fasthx/jinja.py</code> <pre><code>@dataclass(frozen=True, slots=True)\nclass TemplateHeader:\n    \"\"\"\n    Template selector that takes the Jinja template name from a request header.\n\n    This class makes it possible for the client to submit the *key/ID* of the required template\n    to the server in a header. The Jinja decorators will then look up and render the requested\n    template if it exists. If the client doesn't request a specific template, then `default`\n    will be used if it was set, otherwise an exception will be raised.\n\n    By default this class treats template keys as case-insensitive. If you'd like to disable\n    this behavior, set `case_sensitive` to `True`.\n\n    This class can also handle route errors if the `error` property is set.\n\n    Implements:\n        - `RequestComponentSelector[str]`.\n    \"\"\"\n\n    header: str\n    \"\"\"The header which is used by the client to communicate the *key* of the requested template.\"\"\"\n\n    templates: dict[str, str]\n    \"\"\"Dictionary that maps template keys to template (file) names.\"\"\"\n\n    error: type[Exception] | tuple[type[Exception], ...] | None = field(default=None, kw_only=True)\n    \"\"\"The accepted error or errors.\"\"\"\n\n    default: str | None = field(default=None, kw_only=True)\n    \"\"\"The template to use when the client didn't request a specific one.\"\"\"\n\n    case_sensitive: bool = field(default=False, kw_only=True)\n    \"\"\"Whether the keys of `templates` are case-sensitive or not (default is `False`).\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        if not self.case_sensitive:\n            object.__setattr__(\n                self,\n                \"templates\",\n                {k.lower(): v for k, v in self.templates.items()},\n            )\n\n    def get_component(self, request: Request, error: Exception | None) -&gt; str:\n        \"\"\"\n        Returns the name of the template that was requested by the client.\n\n        If the request doesn't contain a header (with the name `self.header`),\n        then `self.default` will be returned if it's not `None`.\n\n        Raises:\n            KeyError: If the client requested a specific template but it's unknown, or\n                if no template was requested and there's no default either.\n        \"\"\"\n        if error is not None and (self.error is None or not isinstance(error, self.error)):\n            raise error\n\n        if (key := request.headers.get(self.header, None)) is not None:\n            if not self.case_sensitive:\n                key = key.lower()\n\n            return self.templates[key]\n        elif self.default is None:\n            raise KeyError(\"Default template was not set and header was not found.\")\n        else:\n            return self.default\n</code></pre>"},{"location":"api/jinja/#fasthx.TemplateHeader.case_sensitive","title":"<code>case_sensitive = field(default=False, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the keys of <code>templates</code> are case-sensitive or not (default is <code>False</code>).</p>"},{"location":"api/jinja/#fasthx.TemplateHeader.default","title":"<code>default = field(default=None, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The template to use when the client didn't request a specific one.</p>"},{"location":"api/jinja/#fasthx.TemplateHeader.error","title":"<code>error = field(default=None, kw_only=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The accepted error or errors.</p>"},{"location":"api/jinja/#fasthx.TemplateHeader.header","title":"<code>header</code>  <code>instance-attribute</code>","text":"<p>The header which is used by the client to communicate the key of the requested template.</p>"},{"location":"api/jinja/#fasthx.TemplateHeader.templates","title":"<code>templates</code>  <code>instance-attribute</code>","text":"<p>Dictionary that maps template keys to template (file) names.</p>"},{"location":"api/jinja/#fasthx.TemplateHeader.get_component","title":"<code>get_component(request, error)</code>","text":"<p>Returns the name of the template that was requested by the client.</p> <p>If the request doesn't contain a header (with the name <code>self.header</code>), then <code>self.default</code> will be returned if it's not <code>None</code>.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the client requested a specific template but it's unknown, or if no template was requested and there's no default either.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>def get_component(self, request: Request, error: Exception | None) -&gt; str:\n    \"\"\"\n    Returns the name of the template that was requested by the client.\n\n    If the request doesn't contain a header (with the name `self.header`),\n    then `self.default` will be returned if it's not `None`.\n\n    Raises:\n        KeyError: If the client requested a specific template but it's unknown, or\n            if no template was requested and there's no default either.\n    \"\"\"\n    if error is not None and (self.error is None or not isinstance(error, self.error)):\n        raise error\n\n    if (key := request.headers.get(self.header, None)) is not None:\n        if not self.case_sensitive:\n            key = key.lower()\n\n        return self.templates[key]\n    elif self.default is None:\n        raise KeyError(\"Default template was not set and header was not found.\")\n    else:\n        return self.default\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaPath","title":"<code>fasthx.JinjaPath</code>","text":"<p>               Bases: <code>str</code></p> <p>String subclass that can be used to mark a template path as \"absolute\".</p> <p>In this context \"absolute\" means the template path should be exempt from any prefixing behavior during template name resolution.</p> <p>Note: calling any of the \"mutation\" methods (e.g. <code>.lower()</code>) of an instance will result in a plain <code>str</code> object.</p> Source code in <code>fasthx/jinja.py</code> <pre><code>class JinjaPath(str):\n    \"\"\"\n    String subclass that can be used to mark a template path as \"absolute\".\n\n    In this context \"absolute\" means the template path should be exempt from any prefixing behavior\n    during template name resolution.\n\n    Note: calling any of the \"mutation\" methods (e.g. `.lower()`) of an instance will\n    result in a plain `str` object.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContextFactory","title":"<code>fasthx.JinjaContextFactory</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol definition for methods that convert a FastAPI route's result and route context (i.e. the route's arguments) into a Jinja context (<code>dict</code>).</p> Source code in <code>fasthx/typing.py</code> <pre><code>class JinjaContextFactory(Protocol):\n    \"\"\"\n    Protocol definition for methods that convert a FastAPI route's result and route context\n    (i.e. the route's arguments) into a Jinja context (`dict`).\n    \"\"\"\n\n    def __call__(self, *, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"\n        Arguments:\n            route_result: The result of the route.\n            route_context: Every keyword argument the route received.\n\n        Returns:\n            The Jinja context dictionary.\n\n        Raises:\n            ValueError: If converting the arguments to a Jinja context fails.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/jinja/#fasthx.JinjaContextFactory.__call__","title":"<code>__call__(*, route_result, route_context)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>route_result</code> <code>Any</code> <p>The result of the route.</p> required <code>route_context</code> <code>dict[str, Any]</code> <p>Every keyword argument the route received.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>The Jinja context dictionary.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If converting the arguments to a Jinja context fails.</p> Source code in <code>fasthx/typing.py</code> <pre><code>def __call__(self, *, route_result: Any, route_context: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Arguments:\n        route_result: The result of the route.\n        route_context: Every keyword argument the route received.\n\n    Returns:\n        The Jinja context dictionary.\n\n    Raises:\n        ValueError: If converting the arguments to a Jinja context fails.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/","title":"Typing","text":""},{"location":"api/typing/#fasthx.HTMLRenderer","title":"<code>fasthx.HTMLRenderer = SyncHTMLRenderer[Tcontra] | AsyncHTMLRenderer[Tcontra]</code>  <code>module-attribute</code>","text":"<p>Sync or async HTML renderer type.</p>"},{"location":"api/typing/#fasthx.typing.SyncHTMLRenderer","title":"<code>fasthx.typing.SyncHTMLRenderer</code>","text":"<p>               Bases: <code>Protocol[Tcontra]</code></p> <p>Sync HTML renderer definition.</p> Source code in <code>fasthx/typing.py</code> <pre><code>class SyncHTMLRenderer(Protocol[Tcontra]):\n    \"\"\"Sync HTML renderer definition.\"\"\"\n\n    def __call__(self, result: Tcontra, *, context: dict[str, Any], request: Request) -&gt; str | Response:\n        \"\"\"\n        Arguments:\n            result: The result of the route the renderer is used on.\n            context: Every keyword argument the route received.\n            request: The request being served.\n\n        Returns:\n            HTML string (it will be automatically converted to `HTMLResponse`) or a `Response` object.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#fasthx.typing.SyncHTMLRenderer.__call__","title":"<code>__call__(result, *, context, request)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>result</code> <code>Tcontra</code> <p>The result of the route the renderer is used on.</p> required <code>context</code> <code>dict[str, Any]</code> <p>Every keyword argument the route received.</p> required <code>request</code> <code>Request</code> <p>The request being served.</p> required <p>Returns:</p> Type Description <code>str | Response</code> <p>HTML string (it will be automatically converted to <code>HTMLResponse</code>) or a <code>Response</code> object.</p> Source code in <code>fasthx/typing.py</code> <pre><code>def __call__(self, result: Tcontra, *, context: dict[str, Any], request: Request) -&gt; str | Response:\n    \"\"\"\n    Arguments:\n        result: The result of the route the renderer is used on.\n        context: Every keyword argument the route received.\n        request: The request being served.\n\n    Returns:\n        HTML string (it will be automatically converted to `HTMLResponse`) or a `Response` object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#fasthx.typing.AsyncHTMLRenderer","title":"<code>fasthx.typing.AsyncHTMLRenderer</code>","text":"<p>               Bases: <code>Protocol[Tcontra]</code></p> <p>Async HTML renderer definition.</p> Source code in <code>fasthx/typing.py</code> <pre><code>class AsyncHTMLRenderer(Protocol[Tcontra]):\n    \"\"\"Async HTML renderer definition.\"\"\"\n\n    async def __call__(\n        self, result: Tcontra, *, context: dict[str, Any], request: Request\n    ) -&gt; str | Response:\n        \"\"\"\n        Arguments:\n            result: The result of the route the renderer is used on.\n            context: Every keyword argument the route received.\n            request: The request being served.\n\n        Returns:\n            HTML string (it will be automatically converted to `HTMLResponse`) or a `Response` object.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#fasthx.typing.AsyncHTMLRenderer.__call__","title":"<code>__call__(result, *, context, request)</code>  <code>async</code>","text":"<p>Parameters:</p> Name Type Description Default <code>result</code> <code>Tcontra</code> <p>The result of the route the renderer is used on.</p> required <code>context</code> <code>dict[str, Any]</code> <p>Every keyword argument the route received.</p> required <code>request</code> <code>Request</code> <p>The request being served.</p> required <p>Returns:</p> Type Description <code>str | Response</code> <p>HTML string (it will be automatically converted to <code>HTMLResponse</code>) or a <code>Response</code> object.</p> Source code in <code>fasthx/typing.py</code> <pre><code>async def __call__(\n    self, result: Tcontra, *, context: dict[str, Any], request: Request\n) -&gt; str | Response:\n    \"\"\"\n    Arguments:\n        result: The result of the route the renderer is used on.\n        context: Every keyword argument the route received.\n        request: The request being served.\n\n    Returns:\n        HTML string (it will be automatically converted to `HTMLResponse`) or a `Response` object.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#fasthx.typing.RequestComponentSelector","title":"<code>fasthx.typing.RequestComponentSelector</code>","text":"<p>               Bases: <code>Protocol[Tco]</code></p> <p>Component selector protocol that uses the request to select the component that will be rendered.</p> <p>The protocol is runtime-checkable, so it can be used in <code>isinstance()</code>, <code>issubclass()</code> calls.</p> Source code in <code>fasthx/typing.py</code> <pre><code>@runtime_checkable\nclass RequestComponentSelector(Protocol[Tco]):\n    \"\"\"\n    Component selector protocol that uses the request to select the component that will be rendered.\n\n    The protocol is runtime-checkable, so it can be used in `isinstance()`, `issubclass()` calls.\n    \"\"\"\n\n    def get_component(self, request: Request, error: Exception | None) -&gt; Tco:\n        \"\"\"\n        Returns the component that was requested by the client.\n\n        The caller should ensure that `error` will be the exception that was raised by the\n        route or `None` if the route returned normally.\n\n        If an implementation can not or does not want to handle route errors, then the method\n        should re-raise the received exception. Example:\n\n        ```python\n        class MyComponentSelector:\n            def get_component(self, request: Request, error: Exception | None) -&gt; str:\n                if error is not None:\n                    raise error\n\n                ...\n        ```\n\n        Raises:\n            KeyError: If the component couldn't be identified.\n            Exception: The received `error` argument if it was not `None` and the implementation\n                can not handle route errors.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/typing/#fasthx.typing.RequestComponentSelector.get_component","title":"<code>get_component(request, error)</code>","text":"<p>Returns the component that was requested by the client.</p> <p>The caller should ensure that <code>error</code> will be the exception that was raised by the route or <code>None</code> if the route returned normally.</p> <p>If an implementation can not or does not want to handle route errors, then the method should re-raise the received exception. Example:</p> <pre><code>class MyComponentSelector:\n    def get_component(self, request: Request, error: Exception | None) -&gt; str:\n        if error is not None:\n            raise error\n\n        ...\n</code></pre> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the component couldn't be identified.</p> <code>Exception</code> <p>The received <code>error</code> argument if it was not <code>None</code> and the implementation can not handle route errors.</p> Source code in <code>fasthx/typing.py</code> <pre><code>def get_component(self, request: Request, error: Exception | None) -&gt; Tco:\n    \"\"\"\n    Returns the component that was requested by the client.\n\n    The caller should ensure that `error` will be the exception that was raised by the\n    route or `None` if the route returned normally.\n\n    If an implementation can not or does not want to handle route errors, then the method\n    should re-raise the received exception. Example:\n\n    ```python\n    class MyComponentSelector:\n        def get_component(self, request: Request, error: Exception | None) -&gt; str:\n            if error is not None:\n                raise error\n\n            ...\n    ```\n\n    Raises:\n        KeyError: If the component couldn't be identified.\n        Exception: The received `error` argument if it was not `None` and the implementation\n            can not handle route errors.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/typing/#fasthx.typing.ComponentSelector","title":"<code>fasthx.typing.ComponentSelector = T | RequestComponentSelector[T]</code>  <code>module-attribute</code>","text":"<p>Type alias for known component selectors.</p>"},{"location":"examples/","title":"Examples","text":"<p>The pages below offer a glimpse of the capabilities of <code>FastHX</code>.</p> <p>For complete, but simple examples that showcase the basic use of <code>FastHX</code>, please see the examples folder of the repository.</p>"},{"location":"examples/#external-examples","title":"External examples","text":"<ul> <li>lipsum-chat: A simple chat application using <code>htmy</code> for server-side rendering, and HTMX, TailwindCSS v4 and DaisyUI v5 for the frontend.</li> <li>FastAPI-HTMX-Tailwind example: A complex <code>Jinja2</code> example with features like active search, lazy-loading, server-sent events, custom server-side HTMX triggers, dialogs, and TailwindCSS and DaisyUI integration.</li> </ul>"},{"location":"examples/custom-templating/","title":"Custom Templating","text":"<p>If you're not into Jinja templating, the <code>hx()</code> and <code>page()</code> decorators give you all the flexibility you need: you can integrate any HTML rendering or templating engine into <code>fasthx</code> simply by implementing the <code>HTMLRenderer</code> protocol. Similarly to the Jinja case, <code>hx()</code> only triggers HTML rendering for HTMX requests, while <code>page()</code> unconditionally renders HTML. See the example code below:</p> <pre><code>from typing import Annotated, Any\n\nfrom fastapi import Depends, FastAPI, Request\nfrom fasthx import hx, page\n\n# Create the app.\napp = FastAPI()\n\n# Create a dependecy to see that its return value is available in the render function.\ndef get_random_number() -&gt; int:\n    return 4  # Chosen by fair dice roll.\n\nDependsRandomNumber = Annotated[int, Depends(get_random_number)]\n\n# Create the render methods: they must always have these three arguments.\n# If you're using static type checkers, the type hint of `result` must match\n# the return type annotation of the route on which this render method is used.\ndef render_index(result: list[dict[str, str]], *, context: dict[str, Any], request: Request) -&gt; str:\n    return \"&lt;h1&gt;Hello FastHX&lt;/h1&gt;\"\n\ndef render_user_list(result: list[dict[str, str]], *, context: dict[str, Any], request: Request) -&gt; str:\n    # The value of the `DependsRandomNumber` dependency is accessible with the same name as in the route.\n    random_number = context[\"random_number\"]\n    lucky_number = f\"&lt;h1&gt;{random_number}&lt;/h1&gt;\"\n    users = \"\".join((\"&lt;ul&gt;\", *(f\"&lt;li&gt;{u['name']}&lt;/li&gt;\" for u in result), \"&lt;/ul&gt;\"))\n    return f\"{lucky_number}\\n{users}\"\n\n@app.get(\"/\")\n@page(render_index)\ndef index() -&gt; None:\n    ...\n\n@app.get(\"/htmx-or-data\")\n@hx(render_user_list)\ndef htmx_or_data(random_number: DependsRandomNumber) -&gt; list[dict[str, str]]:\n    return [{\"name\": \"Joe\"}]\n\n@app.get(\"/htmx-only\")\n@hx(render_user_list, no_data=True)\nasync def htmx_only(random_number: DependsRandomNumber) -&gt; list[dict[str, str]]:\n    return [{\"name\": \"Joe\"}]\n</code></pre>"},{"location":"examples/htmy/","title":"HTMY","text":"<p>The primary focus of this example is how to create htmy components that work together with <code>fasthx</code> and make use of its utilities. The components use TailwindCSS for styling -- if you are not familiar with TailwindCSS, just ignore the <code>class_=\"...\"</code> arguments, they are not important from the perspective of <code>fasthx</code> and <code>htmy</code>. The focus should be on the htmy components, context usage, and route decorators.</p> <p>First, let's create an <code>htmy_app.py</code> file, import everything that is required for the example, and also define a simple Pydantic <code>User</code> model for the application:</p> <pre><code>import random\nfrom dataclasses import dataclass\nfrom datetime import date\n\nfrom fastapi import FastAPI\nfrom htmy import Component, Context, html\nfrom pydantic import BaseModel\n\nfrom fasthx.htmy import HTMY, ComponentHeader, CurrentRequest, RouteParams\n\n\nclass User(BaseModel):\n    \"\"\"User model.\"\"\"\n\n    name: str\n    birthday: date\n</code></pre> <p>The main content on the user interface will be a user list, so let's start by creating a simple <code>UserListItem</code> component:</p> <pre><code>@dataclass\nclass UserListItem:\n    \"\"\"User list item component.\"\"\"\n\n    user: User\n\n    def htmy(self, context: Context) -&gt; Component:\n        return html.li(\n            html.span(self.user.name, class_=\"font-semibold\"),\n            html.em(f\" (born {self.user.birthday.isoformat()})\"),\n            class_=\"text-lg\",\n        )\n</code></pre> <p>As you can see, the component has a single <code>user</code> property and it renders an <code>&lt;li&gt;</code> HTML element with the user's name and birthday in it.</p> <p>The next component we need is the user list itself. This is going to be the most complex part of the example:</p> <ul> <li>To showcase <code>htmy</code> context usage, this component will display some information about the application's state in addition to the list of users.</li> <li>We will also add a bit of HTMX to the component to make it re-render every second.</li> </ul> <pre><code>@dataclass\nclass UserOverview:\n    \"\"\"\n    Component that shows a user list and some additional info about the application's state.\n\n    The component reloads itself every second.\n    \"\"\"\n\n    users: list[User]\n    ordered: bool = False\n\n    def htmy(self, context: Context) -&gt; Component:\n        # Load the current request from the context.\n        request = CurrentRequest.from_context(context)\n        # Load route parameters (resolved dependencies) from the context.\n        route_params = RouteParams.from_context(context)\n        # Get the user-agent from the context which is added by a request processor.\n        user_agent: str = context[\"user-agent\"]\n        # Get the rerenders query parameter from the route parameters.\n        rerenders: int = route_params[\"rerenders\"]\n\n        # Create the user list item generator.\n        user_list_items = (UserListItem(u) for u in self.users)\n\n        # Create the ordered or unordered user list.\n        user_list = (\n            html.ol(*user_list_items, class_=\"list-decimal list-inside\")\n            if self.ordered\n            else html.ul(*user_list_items, class_=\"list-disc list-inside\")\n        )\n\n        # Randomly decide whether an ordered or unordered list should be rendered next.\n        next_variant = random.choice((\"ordered\", \"unordered\"))  # noqa: S311\n\n        return html.div(\n            # -- Some content about the application state.\n            html.p(html.span(\"Last request: \", class_=\"font-semibold\"), str(request.url)),\n            html.p(html.span(\"User agent: \", class_=\"font-semibold\"), user_agent),\n            html.p(html.span(\"Re-renders: \", class_=\"font-semibold\"), str(rerenders)),\n            html.hr(),\n            # -- User list.\n            user_list,\n            # -- HTMX directives.\n            hx_trigger=\"load delay:1000\",\n            hx_get=f\"/users?rerenders={rerenders+1}\",\n            hx_swap=\"outerHTML\",\n            # Send the next component variant in an X-Component header.\n            hx_headers=f'{{\"X-Component\": \"{next_variant}\"}}',\n            # -- Styling\n            class_=\"flex flex-col gap-4\",\n        )\n</code></pre> <p>Most of this code is basic Python and <code>htmy</code> usage (including the <code>hx_*</code> <code>HTMX</code> attributes). The important, <code>fasthx</code>-specific things that require special attention are:</p> <ul> <li>The use of <code>CurrentRequest.from_context()</code> to get access to the current <code>fastapi.Request</code> instance.</li> <li>The use of <code>RouteParams.from_context()</code> to get access to every route parameter (resolved FastAPI dependency) as a mapping.</li> <li>The <code>context[\"user-agent\"]</code> lookup that accesses a value from the context which will be added by a request processor later in the example.</li> </ul> <p>We need one last <code>htmy</code> component, the index page. Most of this component is just the basic HTML document structure with some TailwindCSS styling and metadata. There is also a bit of <code>HTMX</code> in the <code>body</code> for lazy loading the actual page content, the user list we just created.</p> <pre><code>@dataclass\nclass IndexPage:\n    \"\"\"Index page with TailwindCSS styling.\"\"\"\n\n    def htmy(self, context: Context) -&gt; Component:\n        return (\n            html.DOCTYPE.html,\n            html.html(\n                html.head(\n                    # Some metadata\n                    html.title(\"FastHX + HTMY example\"),\n                    html.meta.charset(),\n                    html.meta.viewport(),\n                    # TailwindCSS\n                    html.script(src=\"https://cdn.tailwindcss.com\"),\n                    # HTMX\n                    html.script(src=\"https://unpkg.com/htmx.org@2.0.2\"),\n                ),\n                html.body(\n                    # Page content: lazy-loaded user list.\n                    html.div(hx_get=\"/users\", hx_trigger=\"load\", hx_swap=\"outerHTML\"),\n                    class_=(\n                        \"h-screen w-screen flex flex-col items-center justify-center \"\n                        \" gap-4 bg-slate-800 text-white\"\n                    ),\n                ),\n            ),\n        )\n</code></pre> <p>With all the components ready, we can now create the <code>FastAPI</code> and <code>fasthx.htmy.HTMY</code> instances:</p> <pre><code># Create the app instance.\napp = FastAPI()\n\n# Create the FastHX HTMY instance that renders all route results.\nhtmy = HTMY(\n    # Register a request processor that adds a user-agent key to the htmy context.\n    request_processors=[\n        lambda request: {\"user-agent\": request.headers.get(\"user-agent\")},\n    ]\n)\n</code></pre> <p>Note how we added a request processor function to the <code>HTMY</code> instance that takes the current FastAPI <code>Request</code> and returns a context mapping that is merged into the <code>htmy</code> rendering context and made available to every component.</p> <p>All that remains now is the routing. We need two routes: one that serves the index page, and one that renders the ordered or unordered user list.</p> <p>The index page route is trivial. The <code>htmy.page()</code> decorator expects a component factory (well more precisely a <code>fasthx.ComponentSelector</code>) that accepts the route's return value and returns an <code>htmy</code> component. Since <code>IndexPage</code> has no properties, we use a simple <code>lambda</code> to create such a function:</p> <pre><code>@app.get(\"/\")\n@htmy.page(lambda _: IndexPage())\ndef index() -&gt; None:\n    \"\"\"The index page of the application.\"\"\"\n    ...\n</code></pre> <p>The <code>/users</code> route is a bit more complex: we need to use the <code>fasthx.htmy.ComponentHeader</code> utility, because depending on the value of the <code>X-Component</code> header (remember the <code>hx_headers</code> declaration in <code>UserOverview.htmy()</code>) it must render the route's result either with the ordered or unordered version of <code>UserOverview</code>.</p> <p>The route also has a <code>rerenders</code> query parameter just to showcase how <code>fasthx</code> makes resolved route dependencies accessible to components through the <code>htmy</code> rendering context (see <code>UserOverview.htmy()</code> for details).</p> <p>The full route declaration is as follows:</p> <pre><code>@app.get(\"/users\")\n@htmy.hx(\n    # Use a header-based component selector that can serve ordered or\n    # unordered user lists, depending on what the client requests.\n    ComponentHeader(\n        \"X-Component\",\n        {\n            \"ordered\": lambda users: UserOverview(users, True),\n            \"unordered\": UserOverview,\n        },\n        default=UserOverview,\n    )\n)\ndef get_users(rerenders: int = 0) -&gt; list[User]:\n    \"\"\"Returns the list of users in random order.\"\"\"\n    result = [\n        User(name=\"John\", birthday=date(1940, 10, 9)),\n        User(name=\"Paul\", birthday=date(1942, 6, 18)),\n        User(name=\"George\", birthday=date(1943, 2, 25)),\n        User(name=\"Ringo\", birthday=date(1940, 7, 7)),\n    ]\n    random.shuffle(result)\n    return result\n</code></pre> <p>We finally have everything, all that remains is running our application. Depending on how you installed FastAPI, you can do this for example with:</p> <ul> <li>the <code>fastapi</code> CLI like this: <code>fastapi dev htmy_app.py</code>,</li> <li>or with <code>uvicorn</code> like this: <code>uvicorn htmy_app:app --reload</code>.</li> </ul> <p>If everything went well, the application will be available at <code>http://127.0.0.1:8000</code>.</p>"},{"location":"examples/jinja-templating/","title":"Jinja Templating","text":""},{"location":"examples/jinja-templating/#basics","title":"Basics","text":"<p>To start serving HTML and HTMX requests, all you need to do is create an instance of <code>fasthx.Jinja</code> and use its <code>hx()</code> or <code>page()</code> methods as decorators on your routes. <code>hx()</code> only triggers HTML rendering for HTMX requests, while <code>page()</code> unconditionally renders HTML, saving you some boilerplate code. See the example code below:</p> <pre><code>from fastapi import FastAPI\nfrom fastapi.templating import Jinja2Templates\nfrom fasthx import Jinja\nfrom pydantic import BaseModel\n\n# Pydantic model of the data the example API is using.\nclass User(BaseModel):\n    first_name: str\n    last_name: str\n\n# Create the app.\napp = FastAPI()\n\n# Create a FastAPI Jinja2Templates instance and use it to create a\n# FastHX Jinja instance that will serve as your decorator.\njinja = Jinja(Jinja2Templates(\"templates\"))\n\n@app.get(\"/\")\n@jinja.page(\"index.html\")\ndef index() -&gt; None:\n    ...\n\n@app.get(\"/user-list\")\n@jinja.hx(\"user-list.html\")\nasync def htmx_or_data() -&gt; list[User]:\n    return [\n        User(first_name=\"John\", last_name=\"Lennon\"),\n        User(first_name=\"Paul\", last_name=\"McCartney\"),\n        User(first_name=\"George\", last_name=\"Harrison\"),\n        User(first_name=\"Ringo\", last_name=\"Starr\"),\n    ]\n\n@app.get(\"/admin-list\")\n@jinja.hx(\"user-list.html\", no_data=True)\ndef htmx_only() -&gt; list[User]:\n    return [User(first_name=\"Billy\", last_name=\"Shears\")]\n</code></pre>"},{"location":"examples/jinja-templating/#using-templateheader","title":"Using <code>TemplateHeader</code>","text":"<p>In the basic example, routes always rendered a fixed HTML template. <code>TemplateHeader</code> lifts this restriction by letting the client submit the key of the required template, automatically looking up the corresponding template, and of course rendering it.</p> <p>This can be particularly helpful when multiple templates/UI components require the same data and business logic.</p> <pre><code>app = FastAPI()\njinja = Jinja(Jinja2Templates(\"templates\"))\n\n@app.get(\"/profile/{id}\")\n@jinja.hx(\n    TemplateHeader(\n        \"X-Component\",\n        {\n            \"card\": \"profile/card.jinja\",\n            \"form\": \"profile/form.jinja\",\n        },\n        default=\"profile/card.jinja\",\n    ),\n)\ndef get_user_by_id(id: int) -&gt; User:\n    return get_user_from_db(id)\n</code></pre> <p>Given the example above, if the client submits an <code>HX-Request</code> which includes an <code>X-Component</code> header, the server will render <code>profile/card.jinja</code> if <code>X-Component</code>'s value is <code>\"card\"</code>, and <code>profile/form.jinja</code> if the value is <code>\"form\"</code>. If the <code>X-Component</code> header is missing, the default (<code>profile/card.jinja</code>) will be rendered.</p> <p>If you're tired of repeating <code>\"profile/\"</code>, you can just set <code>prefix=\"profile\"</code> in the <code>hx()</code> (or <code>page()</code>) decorator.</p>"},{"location":"migrations/1-to-2/","title":"From v1 to v2","text":"<p>Version 2 added exception rendering as the main feature, which required some API changes. Here is how you should upgrade your code to be compatible with version 2:</p> <ul> <li>If you have custom <code>RequestComponentSelector</code> implementations:<ul> <li>Rename <code>get_component_id()</code> methods to <code>get_component()</code> and add the new <code>error: Exception | None</code> argument to the methods.</li> <li>Well-behaved <code>RequestComponentSelector</code>s that dont's support error rendering should reraise the received error if it's not <code>None</code> (although not doing so will not break anything as result and errors are clearly separated in <code>Jinja</code> and the core decorators don't rely on this protocol).</li> </ul> </li> <li>If you've overridden any of the protected methods of <code>Jinja</code>, please go through this PR so you can upgrade your custom implementation.</li> <li>If you've written a custom integration, just add the required generic type to ComponentSelector type hints.</li> </ul>"}]}